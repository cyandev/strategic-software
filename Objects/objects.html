<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="style.css">
  <title>Strategic Software</title>
</head>
<body>
  <a href="../index.html">Home</a>
  <h1>Objects</h1>
  <p>This page documents objects. The Javascript for this page logs to the console, please open the Web Console on your device.</p>

  <h2>Javascript</h2>
  <div class="javascript">
    <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">/*</span>
    <span style="color: #888888">  In javascript, we can create object literals using brackets {}</span>
    <span style="color: #888888">  White space and newlines are irrelevant, so we can space out the</span>
    <span style="color: #888888">    code to be more readable.</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">var</span> dog <span style="color: #333333">=</span> {
      breed<span style="color: #333333">:</span> <span style="background-color: #fff0f0">&quot;Shiba Inu&quot;</span>,
      name<span style="color: #333333">:</span> <span style="background-color: #fff0f0">&quot;Jimmothy&quot;</span>
    };
    <span style="color: #888888">//the object itself can be logged</span>
    console.log(dog);
    <span style="color: #888888">//the properties can also be logged</span>
    console.log(dog.breed);
    console.log(dog.name);

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  Object literals can be created with methods as well. This is done</span>
    <span style="color: #888888">    by assigning a property to a function definition</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">var</span> cat <span style="color: #333333">=</span> {
      color<span style="color: #333333">:</span> <span style="background-color: #fff0f0">&quot;Orange&quot;</span>,
      name<span style="color: #333333">:</span> <span style="background-color: #fff0f0">&quot;Frank&quot;</span>,
      speak<span style="color: #333333">:</span> <span style="color: #008800; font-weight: bold">function</span>(){
        console.log(<span style="background-color: #fff0f0">&quot;Meow&quot;</span>);
      }
    }
    <span style="color: #888888">//the function assignment itself can be accessed</span>
    console.log(cat.speak);
    <span style="color: #888888">//use () to call the method</span>
    cat.speak();

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  Methods can access object properties using the &quot;this&quot; keyword</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">var</span> parrot <span style="color: #333333">=</span> {
      name<span style="color: #333333">:</span> <span style="background-color: #fff0f0">&quot;George&quot;</span>,
      speak<span style="color: #333333">:</span> <span style="color: #008800; font-weight: bold">function</span>(){
        console.log(<span style="background-color: #fff0f0">&quot;Hello, my name is &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.name);
      }
    }
    parrot.speak();

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  Properties and methods can be added to objects, and object properties can be</span>
    <span style="color: #888888">    edited directly</span>
    <span style="color: #888888">*/</span>
    dog.breed <span style="color: #333333">=</span> <span style="background-color: #fff0f0">&quot;Samoyed&quot;</span>;
    dog.speak <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
      console.log(<span style="background-color: #fff0f0">&quot;Bork&quot;</span>);
    }
    console.log(dog.breed);
    dog.speak();

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  Based on this knowledge, we can use Javscript functions to construct</span>
    <span style="color: #888888">    and return and object. Important: this is not generally how we will</span>
    <span style="color: #888888">    use classes and constructors, this is for better understanding objects</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">function</span> makeAnimal(){
      <span style="color: #888888">//create an animal</span>
      <span style="color: #008800; font-weight: bold">var</span> animal <span style="color: #333333">=</span> {};
      animal.name <span style="color: #333333">=</span> <span style="background-color: #fff0f0">&quot;name&quot;</span>;
      animal.age <span style="color: #333333">=</span> <span style="background-color: #fff0f0">&quot;age&quot;</span>;
      animal.speak <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
        console.log(<span style="background-color: #fff0f0">&quot;Hello, my name is &quot;</span><span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.name);
      }
      <span style="color: #888888">//return the animal object</span>
      <span style="color: #008800; font-weight: bold">return</span> animal;
    }

    <span style="color: #888888">//assign a variable to be an object produced by the makeAnimal function</span>
    <span style="color: #008800; font-weight: bold">var</span> dolphin <span style="color: #333333">=</span> makeAnimal();
    console.log(dolphin.name);
    dolphin.speak();

    <span style="color: #888888">//the object &quot;animal&quot; is local to the makeAnimal function, so doing this will not work</span>
    <span style="color: #888888">//animal.speak(); /*produces error*/</span>

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  Functions can also take parameters to construct different objects. This is called a factory function.</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">function</span> makePerson(name, age){
      <span style="color: #008800; font-weight: bold">var</span> person <span style="color: #333333">=</span> {};
      person.name <span style="color: #333333">=</span> name;
      person.age <span style="color: #333333">=</span> age;
      person.speak <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
        console.log(<span style="background-color: #fff0f0">&quot;Hello, my name is &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.name);
      }
      <span style="color: #008800; font-weight: bold">return</span> person;
    }

    <span style="color: #008800; font-weight: bold">var</span> adam <span style="color: #333333">=</span> makePerson(<span style="background-color: #fff0f0">&quot;Adam&quot;</span>, <span style="color: #0000DD; font-weight: bold">17</span>);
    <span style="color: #008800; font-weight: bold">var</span> shoop <span style="color: #333333">=</span> makePerson(<span style="background-color: #fff0f0">&quot;Shilpa&quot;</span>, <span style="color: #0000DD; font-weight: bold">17</span>);
    adam.speak();
    shoop.speak();
    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  Classes are more commonly done in a way more similar to Java. The object</span>
    <span style="color: #888888">    constructor is built into the class definition. By convention, the first</span>
    <span style="color: #888888">    letter should be capitalized. The constructor function does not have to return</span>
    <span style="color: #888888">    anything, the object will be obtained using the &quot;new&quot; keyword.</span>

    <span style="color: #888888">  Because there is nothing being returned, class properties cannot be assigned to a</span>
    <span style="color: #888888">    local object literal. Therefore, use the &quot;this&quot; keyword when assigning properties</span>
    <span style="color: #888888">    and methods.</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">function</span> Person(name, age){
      <span style="color: #008800; font-weight: bold">this</span>.name <span style="color: #333333">=</span> name;
      <span style="color: #008800; font-weight: bold">this</span>.age <span style="color: #333333">=</span> age;
      <span style="color: #008800; font-weight: bold">this</span>.speak <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
        console.log(<span style="background-color: #fff0f0">&quot;Hello, my name is &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.name);
      }
    }
    <span style="color: #888888">//objects are initialized with the &quot;new&quot; keyword, the same as in Java</span>
    <span style="color: #008800; font-weight: bold">var</span> jacob <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Person(<span style="background-color: #fff0f0">&quot;Jacob&quot;</span>, <span style="color: #0000DD; font-weight: bold">17</span>);
    jacob.speak();

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  In general, methods should not be defined within the constructor like they</span>
    <span style="color: #888888">    are in the example above. In this example, every time an object is created,</span>
    <span style="color: #888888">    the speak function is defined, and stored for that object. This is somewhat</span>
    <span style="color: #888888">    similar to private methods in Java.</span>

    <span style="color: #888888">  When logging the object itself, we can see that each has it&#39;s own version</span>
    <span style="color: #888888">    of an identical function.</span>
    <span style="color: #888888">*/</span>
    <span style="color: #008800; font-weight: bold">var</span> aditya <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Person(<span style="background-color: #fff0f0">&quot;Aditya&quot;</span>,<span style="color: #0000DD; font-weight: bold">17</span>);
    console.log(jacob);
    console.log(aditya);

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  In most cases, proper practice is to use Javascript&#39;s &quot;prototype&quot; to add methods</span>
    <span style="color: #888888">    onto the class. All objects created will still have access to the method, and</span>
    <span style="color: #888888">    functionality will be identical, but performance is improved when initializing</span>
    <span style="color: #888888">    objects.</span>

    <span style="color: #888888">    When using prototype to add a method, instance variables can still be accessed</span>
    <span style="color: #888888">      using the &quot;this&quot; keyword.</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">function</span> Animal(name, age){
      <span style="color: #008800; font-weight: bold">this</span>.name <span style="color: #333333">=</span> name;
      <span style="color: #008800; font-weight: bold">this</span>.age <span style="color: #333333">=</span> age
    }
    Animal.prototype.speak <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">function</span>(){
      console.log(<span style="background-color: #fff0f0">&quot;Hello, my name is &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.name);
    }

    <span style="color: #008800; font-weight: bold">var</span> frog <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Animal(<span style="background-color: #fff0f0">&quot;Fred&quot;</span>, <span style="color: #0000DD; font-weight: bold">27</span>);
    <span style="color: #008800; font-weight: bold">var</span> fish <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Animal(<span style="background-color: #fff0f0">&quot;Joe&quot;</span>, <span style="color: #0000DD; font-weight: bold">14</span>);
    frog.speak();
    fish.speak();

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  If we log the Animal objects created with the prototype constructor,</span>
    <span style="color: #888888">    we can see that the speak method is not stored as a literal on the object.</span>
    <span style="color: #888888">    This is also beneficial, because if we were to edit the speak method after the objects</span>
    <span style="color: #888888">    were initialized, Animal objects would be able to access the updated method,</span>
    <span style="color: #888888">    while Person objects would continue to use the method stored on their instance.</span>
    <span style="color: #888888">*/</span>
    console.log(frog);
    console.log(fish);

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  In newer versions of Javascript, we also have classes that are just like Classes</span>
    <span style="color: #888888">    in other languages. This allows us to use static, extend, and other stuff</span>
    <span style="color: #888888">    people might know from Java.</span>

    <span style="color: #888888">  Instance variables must be defined in the constructor method</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">class</span> ClassExample {
      constructor(){
        <span style="color: #008800; font-weight: bold">this</span>.name <span style="color: #333333">=</span> <span style="background-color: #fff0f0">&quot;test&quot;</span>;
      }
      speak() {
        console.log(<span style="background-color: #fff0f0">&quot;This is a test&quot;</span>)
      }
    }

    <span style="color: #008800; font-weight: bold">var</span> testClassExample <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> ClassExample();
    console.log(testClassExample.name)
    testClassExample.speak();


    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  If we create another ClassExample object, we can see that this</span>
    <span style="color: #888888">    syntax behaves identically to the constructor syntax with regard to</span>
    <span style="color: #888888">    prototype. Instance variables are independant, but the methods are prototype.</span>
    <span style="color: #888888">*/</span>


    <span style="color: #008800; font-weight: bold">var</span> testClassExample2 <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> ClassExample();
    console.log(testClassExample);
    console.log(testClassExample2);

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  Using this new syntax, we can demonstrate a more complex example. This class is</span>
    <span style="color: #888888">    going to demonstrate special forms of getting and setting in Javascript, as well</span>
    <span style="color: #888888">    as showing how instance variables can be read and mutated by other methods.</span>
    <span style="color: #888888">*/</span>

    <span style="color: #008800; font-weight: bold">class</span> Robot {
      constructor(number, name, batteryCharge){
        <span style="color: #008800; font-weight: bold">this</span>.number <span style="color: #333333">=</span> number;
        <span style="color: #008800; font-weight: bold">this</span>.name <span style="color: #333333">=</span> name;
        <span style="color: #008800; font-weight: bold">this</span>.batteryCharge <span style="color: #333333">=</span> batteryCharge;
      }
      <span style="color: #888888">/*</span>
    <span style="color: #888888">    Getter:</span>
    <span style="color: #888888">      A method specified with the &quot;get&quot; keyword, that returns a value, can have</span>
    <span style="color: #888888">        that value accessed as if it were a property. That is, if the method name</span>
    <span style="color: #888888">        ( without ()) is called, it will return the return value, rather than the</span>
    <span style="color: #888888">        function literal.</span>
    <span style="color: #888888">  */</span>
      get teamName(){
        <span style="color: #008800; font-weight: bold">return</span> (<span style="background-color: #fff0f0">&quot;Team &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.number.toString() <span style="color: #333333">+</span> <span style="background-color: #fff0f0">&quot;: &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.name)
      }
      <span style="color: #888888">/*</span>
    <span style="color: #888888">    The same can be accomplished with any other method, but when it is called, it</span>
    <span style="color: #888888">      must have () at the end, or it will return the function literal.</span>
    <span style="color: #888888">  */</span>
      getTeamName(){
        <span style="color: #008800; font-weight: bold">return</span> (<span style="background-color: #fff0f0">&quot;Team &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.number.toString() <span style="color: #333333">+</span> <span style="background-color: #fff0f0">&quot;: &quot;</span> <span style="color: #333333">+</span> <span style="color: #008800; font-weight: bold">this</span>.name)
      }
      <span style="color: #888888">/*</span>
    <span style="color: #888888">    Setter:</span>
    <span style="color: #888888">      Setting methods are like getters, but in the other direction. These</span>
    <span style="color: #888888">        are kind of weirder. With the set keyword, we can call the method as</span>
    <span style="color: #888888">        if accessing a property, and if we give parameters to the set method,</span>
    <span style="color: #888888">        we input them by assignment.</span>
    <span style="color: #888888">      Despite the name, we don&#39;t need to just set an instance variable to a</span>
    <span style="color: #888888">        parameter. The method can also do calculations, or increment the</span>
    <span style="color: #888888">        variable. Setter functions msut have exactly 1 argument.</span>
    <span style="color: #888888">  */</span>
      set charge(amount){
        <span style="color: #008800; font-weight: bold">this</span>.batteryCharge <span style="color: #333333">+=</span> amount;
      }
      <span style="color: #888888">//again, the same can be accomplished with other methods</span>
      chargeBattery(amount){
        <span style="color: #008800; font-weight: bold">this</span>.batteryCharge <span style="color: #333333">+=</span> amount;
      }
    }
    <span style="color: #008800; font-weight: bold">var</span> bombSquad <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">new</span> Robot(<span style="color: #0000DD; font-weight: bold">16</span>, <span style="background-color: #fff0f0">&quot;Bomb Squad&quot;</span>, <span style="color: #0000DD; font-weight: bold">12</span>);
    <span style="color: #888888">//Instance variables</span>
    console.log(bombSquad.number);
    console.log(bombSquad.name);
    console.log(bombSquad.batteryCharge);
    <span style="color: #888888">//Get keyword</span>
    console.log(bombSquad.teamName);
    <span style="color: #888888">//Getter method (outputs the same thing)</span>
    console.log(bombSquad.getTeamName())

    <span style="color: #888888">//Showing setting</span>
    bombSquad.charge <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">3</span>; <span style="color: #888888">//I find this counter intuitive, personally</span>
    console.log(bombSquad.batteryCharge);
    bombSquad.chargeBattery(<span style="color: #0000DD; font-weight: bold">3</span>);
    console.log(bombSquad.batteryCharge);

    <span style="color: #888888">/*</span>
    <span style="color: #888888">  This class syntax is nice, because all methods are shown neatly in the same place.</span>
    <span style="color: #888888">    Because it is relatively newer, code references will often show the older ways</span>
    <span style="color: #888888">    of creating object templates, generally the object constructor syntax. For our</span>
    <span style="color: #888888">    purposes, we will mostly use the class syntax, for familiarity.</span>
    <span style="color: #888888">*/</span>

    console.log(<span style="background-color: #fff0f0">&quot;------------------------------------------------------&quot;</span>) <span style="color: #888888">//Line break</span>
    </pre></div>


  </div>


  <script src="main.js"></script>
</body>
</html>
